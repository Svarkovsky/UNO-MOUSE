#!/bin/bash

# Check for ImageMagick and xxd
if ! command -v convert &> /dev/null || ! command -v identify &> /dev/null || ! command -v xxd &> /dev/null
then
    echo "Error: ImageMagick or xxd not found."
    echo "Please install ImageMagick (e.g., sudo apt install imagemagick) and xxd (usually part of vim-common or binutils)."
    exit 1
fi

# Check for input files
if [ $# -eq 0 ]
then
    echo "Usage: $0 <image_file1> [image_file2 ...]"
    echo "Example: $0 parrot.jpg bird.jpg"
    echo ""
    echo "Target resolution: 128x96 pixels."
    echo "Images will be scaled with aspect ratio preserved and background filled."
    echo "Output files: images.h, images.cpp, images.ino, <name>.pbm for each image"
    exit 1
fi

# Target resolution
TARGET_WIDTH=128
TARGET_HEIGHT=96
DECOMPRESSED_BYTE_SIZE=$((TARGET_WIDTH * TARGET_HEIGHT / 8)) # 1536 bytes

# Project name (for .h, .cpp, .ino files)
PROJECT_NAME="images"

# Create output directory
output_dir="converted_${PROJECT_NAME}"
mkdir -p "$output_dir"

# Output files
cpp_file="${output_dir}/${PROJECT_NAME}.cpp"
h_file="${output_dir}/${PROJECT_NAME}.h"
ino_file="${output_dir}/${PROJECT_NAME}.ino"

echo "Converting image(s) to directory '$output_dir'..."

# --- Create .h file ---
echo "// Header file for images" > "$h_file"
echo "// Generated by convert_image.sh script" >> "$h_file"
echo "#ifndef ${PROJECT_NAME^^}_H" > "$h_file"
echo "#define ${PROJECT_NAME^^}_H" >> "$h_file"
echo "" >> "$h_file"
echo "#include <avr/pgmspace.h>" >> "$h_file"
echo "" >> "$h_file"

# Declare arrays for each image
image_names=()
for img in "$@"; do
    base_name="$(basename "$img" | cut -d. -f1)"
    name=$(echo "$base_name" | sed 's/[^a-zA-Z0-9_]/_/g' | sed 's/^[0-9]/_&/')
    if [ -z "$name" ]; then
        name="image_data"
    fi
    image_names+=("$name")
    echo "extern const unsigned char ${name}_compressed[];" >> "$h_file" # Declare compressed array
done

echo "" >> "$h_file"
echo "#endif // ${PROJECT_NAME^^}_H" >> "$h_file"

# --- Create .cpp file ---
echo "// Data file for images (RLE compressed)" > "$cpp_file"
echo "// Generated by convert_image.sh script" >> "$cpp_file"
echo "#include \"${PROJECT_NAME}.h\"" >> "$cpp_file"
echo "" >> "$cpp_file"

# Convert each image, RLE compress, and add array to .cpp
for img in "$@"; do
    echo "  - Converting and compressing '$img'..."
    
    # Name for .pbm file
    base_name="$(basename "$img" | cut -d. -f1)"
    name=$(echo "$base_name" | sed 's/[^a-zA-Z0-9_]/_/g' | sed 's/^[0-9]/_&/')
    if [ -z "$name" ]; then
        name="image_data"
    fi
    pbm_file="${output_dir}/${name}.pbm"

    # Step 1: Convert image to PBM
    convert "$img" \
      -resize "${TARGET_WIDTH}x${TARGET_HEIGHT}>" \
      -background black \
      -gravity center \
      -extent "${TARGET_WIDTH}x${TARGET_HEIGHT}" \
      -monochrome \
      -dither FloydSteinberg \
      PBM:- > "$pbm_file"

    # Check: ensure PBM file is created and has data
    if [ ! -s "$pbm_file" ]; then
        echo "Error: Failed to create PBM file for '$img' or it is empty."
        exit 1
    fi

    # Check resolution in PBM file
    dimensions=$(head -n 2 "$pbm_file" | tail -n 1)
    read -r width height <<< "$dimensions"
    if [ "$width" -ne "$TARGET_WIDTH" ] || [ "$height" -ne "$TARGET_HEIGHT" ]; then
        echo "Error: PBM file resolution ($width x $height) does not match target ($TARGET_WIDTH x $TARGET_HEIGHT)."
        exit 1
    fi

    # Check byte count
    expected_bytes=$((TARGET_WIDTH * TARGET_HEIGHT / 8))
    actual_bytes=$(tail -n +3 "$pbm_file" | wc -c)
    if [ "$actual_bytes" -ne "$expected_bytes" ]; then
        echo "Error: Expected $expected_bytes bytes, but got $actual_bytes bytes in '$pbm_file'."
        exit 1
    fi

    # Step 2: Bitwise RLE compression
    # Read raw PBM data (1536 bytes)
    pbm_data=$(tail -n +3 "$pbm_file" | xxd -p | tr -d '\n')

    compressed_data=""
    current_run_count=0
    current_pixel_value="" # "0" or "1"

    # Iterate through bits
    for ((i=0; i < ${#pbm_data}; i+=2)); do
        byte_hex="${pbm_data:i:2}"
        byte_dec=$((16#$byte_hex))

        # Iterate through 8 bits in the byte
        for ((j=7; j>=0; j--)); do
            bit=$(((byte_dec >> j) & 1))
            pixel_value="$bit" # "0" or "1"

            if [ -z "$current_pixel_value" ]; then
                # First pixel
                current_pixel_value="$pixel_value"
                current_run_count=1
            elif [ "$pixel_value" == "$current_pixel_value" ]; then
                # Continuation of sequence
                current_run_count=$((current_run_count + 1))
                # Maximum sequence length in one RLE byte is 127
                if [ "$current_run_count" -eq 127 ]; then
                    # Write current sequence and reset counter
                    rle_byte=$((current_run_count | (current_pixel_value == "1" ? 0x80 : 0x00)))
                    compressed_data="${compressed_data}$(printf '%02x' $rle_byte)"
                    current_run_count=0
                    current_pixel_value="" # Reset so the next pixel starts a new sequence
                fi
            else
                # End of sequence, write the previous one
                rle_byte=$((current_run_count | (current_pixel_value == "1" ? 0x80 : 0x00)))
                compressed_data="${compressed_data}$(printf '%02x' $rle_byte)"
                # Start a new sequence
                current_pixel_value="$pixel_value"
                current_run_count=1
            fi
        done
    done

    # Write the last sequence
    if [ "$current_run_count" -gt 0 ]; then
        rle_byte=$((current_run_count | (current_pixel_value == "1" ? 0x80 : 0x00)))
        compressed_data="${compressed_data}$(printf '%02x' $rle_byte)"
    fi

    compressed_size=$(( ${#compressed_data} / 2 )) # Size in bytes

    echo "  - Compressed size: ${compressed_size} bytes (original: ${DECOMPRESSED_BYTE_SIZE} bytes)"

    # Add compressed array to .cpp
    echo "// RLE compressed data for image '$img'" >> "$cpp_file"
    echo "PROGMEM const unsigned char ${name}_compressed[] = {" >> "$cpp_file"
    # Add decompressed size (2 bytes) and compressed size (2 bytes)
    printf "  %d, %d, %d, %d," $((DECOMPRESSED_BYTE_SIZE & 0xFF)) $(( (DECOMPRESSED_BYTE_SIZE >> 8) & 0xFF )) $((compressed_size & 0xFF)) $(( (compressed_size >> 8) & 0xFF )) >> "$cpp_file"

    # Add compressed RLE data
    echo "$compressed_data" | sed 's/\(..\)/0x\1,/g' | sed 's/,$//' | sed 's/\(0x[0-9a-fA-F]\{2\},\)\{16\}/\0\n  /g' >> "$cpp_file"

    echo "" >> "$cpp_file" # Add new line after data
    echo "};" >> "$cpp_file" # Close array
    echo "" >> "$cpp_file" # Add empty line between arrays
done

# --- Create .ino file ---
cat <<EOF > "$ino_file"
#include <TVout.h>
#include <avr/pgmspace.h> // For pgm_read_byte, pgm_read_word_near

TVout TV;

#include "${PROJECT_NAME}.h"

// Array of pointers to compressed images (in Flash)
const unsigned char * const image_list_compressed[] PROGMEM = {
$(for name in "${image_names[@]}"; do echo "  ${name}_compressed,"; done)
};

// Number of images (in Flash)
const int num_images PROGMEM = ${#image_names[@]};

// --- Function to draw RLE compressed image directly to TVout buffer ---
// Takes a pointer to compressed data in Flash
void draw_rle_bitmap_direct(int start_x, int start_y, const unsigned char* compressed_bmp) {
  // Read decompressed size (2 bytes) and compressed size (2 bytes)
  uint16_t decompressed_size_bytes = pgm_read_word_near(compressed_bmp); // Expected 1536
  uint16_t compressed_size = pgm_read_word_near(compressed_bmp + 2);

  // Pointer to the start of compressed RLE data (after sizes)
  const unsigned char* rle_data_ptr = compressed_bmp + 4;

  int current_pixel_x = start_x;
  int current_pixel_y = start_y;
  int pixels_drawn = 0; // Counter for drawn pixels (to track position)
  int total_pixels_expected = decompressed_size_bytes * 8; // 128 * 96 = 12288 pixels

  // TVout buffer width in bytes (128 / 8 = 16)
  const int TVOUT_BUFFER_BYTE_WIDTH = $TARGET_WIDTH / 8;

  // Read and decompress RLE data
  for (uint16_t i = 0; i < compressed_size; ++i) {
    // Read RLE pair byte from Flash
    unsigned char rle_byte = pgm_read_byte_near(rle_data_ptr + i);

    // Extract count (lower 7 bits)
    int count = rle_byte & 0x7F;
    // Extract pixel value (most significant bit: 0 for black, 1 for white)
    int pixel_value = (rle_byte >> 7) & 0x01; // 0 or 1

    // Determine byte pattern for setting bits (all 8 bits are the same)
    unsigned char bit_pattern = (pixel_value == 1) ? 0xFF : 0x00;

    // Draw count pixels with pixel_value
    for (int j = 0; j < count; ++j) {
      // Check if we exceeded the expected number of pixels
      if (pixels_drawn < total_pixels_expected) {
         // Calculate byte index in the TVout buffer
         int byte_idx = (current_pixel_x / 8) + (current_pixel_y * TVOUT_BUFFER_BYTE_WIDTH);
         // Calculate bit mask within the byte
         int bit_mask = 0x80 >> (current_pixel_x & 7);

         // Set the pixel directly in the TVout buffer (TV.screen)
         if (pixel_value == 1) {
             TV.screen[byte_idx] |= bit_mask; // Set bit to 1 (white)
         } else {
             TV.screen[byte_idx] &= ~bit_mask; // Set bit to 0 (black)
         }

         // Move to the next pixel
         current_pixel_x++;
         pixels_drawn++;

         // If we reached the end of the image row (128 pixels), move to the next row
         if (current_pixel_x >= start_x + $TARGET_WIDTH) {
           current_pixel_x = start_x;
           current_pixel_y++;
           // If we exceeded the image height (96 rows), stop
           if (current_pixel_y >= start_y + $TARGET_HEIGHT) {
             // Reached the end of the image, can exit loops
             goto end_decompression; // Use goto to exit nested loops
           }
         }
      } else {
          // All expected pixels drawn, exit
          goto end_decompression;
      }
    }
  }

end_decompression:; // Label for goto
}


// --- Melody ---
#define NOTE_E5  659
#define NOTE_F5  698
#define NOTE_G5  784
#define NOTE_A5  880
#define NOTE_B5  988
#define NOTE_C6 1047
#define NOTE_D6 1175
#define NOTE_E6 1319

// Melody and durations also in Flash (doubled length)
const int melody[] PROGMEM = {
  NOTE_E5, NOTE_F5, NOTE_G5, NOTE_A5, NOTE_A5, NOTE_G5, NOTE_F5, NOTE_E5,
  NOTE_G5, NOTE_A5, NOTE_B5, NOTE_C6, NOTE_C6, NOTE_B5, NOTE_A5, NOTE_G5,
  NOTE_A5, NOTE_B5, NOTE_C6, NOTE_D6, NOTE_D6, NOTE_C6, NOTE_B5, NOTE_A5,
  NOTE_B5, NOTE_C6, NOTE_D6, NOTE_E6, NOTE_E6, NOTE_D6, NOTE_C6, NOTE_B5,
  NOTE_E5, NOTE_F5, NOTE_G5, NOTE_A5, NOTE_A5, NOTE_G5, NOTE_F5, NOTE_E5,
  NOTE_G5, NOTE_A5, NOTE_B5, NOTE_C6, NOTE_C6, NOTE_B5, NOTE_A5, NOTE_G5,
  NOTE_A5, NOTE_B5, NOTE_C6, NOTE_D6, NOTE_D6, NOTE_C6, NOTE_B5, NOTE_A5,
  NOTE_B5, NOTE_A5, NOTE_G5, NOTE_F5, NOTE_E5, NOTE_D6, NOTE_C6, NOTE_B5,
  // Repeat melody for increased duration
  NOTE_E5, NOTE_F5, NOTE_G5, NOTE_A5, NOTE_A5, NOTE_G5, NOTE_F5, NOTE_E5,
  NOTE_G5, NOTE_A5, NOTE_B5, NOTE_C6, NOTE_C6, NOTE_B5, NOTE_A5, NOTE_G5,
  NOTE_A5, NOTE_B5, NOTE_C6, NOTE_D6, NOTE_D6, NOTE_C6, NOTE_B5, NOTE_A5,
  NOTE_B5, NOTE_C6, NOTE_D6, NOTE_E6, NOTE_E6, NOTE_D6, NOTE_C6, NOTE_B5,
  NOTE_E5, NOTE_F5, NOTE_G5, NOTE_A5, NOTE_A5, NOTE_G5, NOTE_F5, NOTE_E5,
  NOTE_G5, NOTE_A5, NOTE_B5, NOTE_C6, NOTE_C6, NOTE_B5, NOTE_A5, NOTE_G5,
  NOTE_A5, NOTE_B5, NOTE_C6, NOTE_D6, NOTE_D6, NOTE_C6, NOTE_B5, NOTE_A5,
  NOTE_B5, NOTE_A5, NOTE_G5, NOTE_F5, NOTE_E5, NOTE_D6, NOTE_C6, NOTE_B5
};

const int noteDurations[] PROGMEM = {
  2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2,
  // Repeat durations for doubled melody
  2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2
};


void play() {
  // Read melody and duration data from Flash memory
  for (int thisNote = 0; thisNote < sizeof(melody)/sizeof(melody[0]); thisNote++) {
    int base_duration = 120;
    // Read note duration from Flash
    int duration_val = pgm_read_word_near(noteDurations + thisNote);
    int duration_ms = base_duration * (duration_val / 2);
    
    // Read note frequency from Flash
    int note_freq = pgm_read_word_near(melody + thisNote);
    TV.tone(note_freq, duration_ms);

    int pauseBetweenNotes = duration_ms + 20;
    TV.delay(pauseBetweenNotes);

    // Stop tone before the next note
    TV.noTone();
  }
}

void setup() {
  // Initialize TVout with target resolution
  TV.begin(NTSC, $TARGET_WIDTH, $TARGET_HEIGHT);
  // TV.begin(PAL, $TARGET_WIDTH, $TARGET_HEIGHT); // For PAL region

  // --- Adjust horizontal offset ---
  // Default value can be around 10-15.
  // Try starting with 10 or 12 and increase/decrease
  // until the image is centered. 14 is a starting value.
  TV.force_outstart(14); // <-- Starting value
  // ---------------------------------------------

  TV.clear_screen(); // Clear screen
}

void loop() {
  static int current_image = 0;
  
  TV.clear_screen();
  
  // Read pointer to the current compressed image from Flash
  const unsigned char *current_image_compressed_ptr = (const unsigned char *)pgm_read_word_near(image_list_compressed + current_image);
  
  // Display the RLE compressed image at position (0,0)
  draw_rle_bitmap_direct(0, 0, current_image_compressed_ptr);
  
  // Play the melody
  play();
  
  // Delay
  TV.delay(1000);
  
  // Move to the next image
  // Read num_images from Flash
  int total_images = pgm_read_word_near(&num_images);
  current_image = (current_image + 1) % total_images;
}
EOF

echo "Successfully created files in directory '$output_dir':"
echo "  - '$h_file'"
echo "  - '$cpp_file'"
echo "  - '$ino_file'"
for img in "$@"; do
    base_name="$(basename "$img" | cut -d. -f1)"
    name=$(echo "$base_name" | sed 's/[^a-zA-Z0-9_]/_/g' | sed 's/^[0-9]/_&/')
    if [ -z "$name" ]; then
        name="image_data"
    fi
    echo "  - '${output_dir}/${name}.pbm'"
done
echo ""
echo "Copy the contents of this directory (except .pbm files) to your Arduino sketch folder."
echo "Open '$ino_file' in the Arduino IDE."
echo "Ensure a speaker is connected to D11 and GND (via an RC filter)."
echo "Upload the sketch to the board."
